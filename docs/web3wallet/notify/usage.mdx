import PlatformTabs from '../../components/PlatformTabs'
import PlatformTabItem from '../../components/PlatformTabItem'
import CloudBanner from '../../components/CloudBanner'

# Usage

:::caution
Web3Inbox is in beta
:::

In this section, we showcase the aspects of using the Notify API. We'll guide you through the initial steps of initializing the Notify client and logging in a blockchain account. You'll also learn how to manage your subscriptions and messages. Additionally, we cover the process of setting up and displaying push notifications on your preferred platform. To ensure a good user experience, we include best practices for spam protection, helping you to enable the users to maintain control over the notifications wallet receives.

## Content

Links to sections on this page. Some sections are platform specific and are only visible when the platform is selected. To view a summary of useful platform specific topics, check out Extra (Platform Specific) under this section.

- [Initialization](#initialization):
  Creating a new Notify Client instance and initializing it with a projectId from [Cloud](https://cloud.walletconnect.com/).
- [Account login](#account-login): 
  A SIWE message must be signed by the user in order to authorize the client to use Notify API
- [Subscribing to a new dapp](#subscribing-to-a-new-dapp): 
  Opt-in to receive notifications from dapp
- [Fetching active subscriptions](#fetching-active-subscriptions): 
  Get active subscriptions
- [Fetching subscription’s notification](#fetching-subscription’s-notifications): 
  Get notifications of a subscription
- [Updating subscriptions notification settings](#updating-subscriptions-notification-settings): 
  Change allowed notification types sent by dapp
- [Fetching available notification types](#fetching-available-notification-types): 
  Get latest notification types
- [Unsubscribe from a dapp](#unsubscribe-from-a-dapp): 
  Opt-out from receiving notifications from a dapp
- [Delete subscription message](#delete-subscription-message): 
  Delete a single message from local storage
- [Account logout](#account-logout):
  To stop receiving notifications to this client, accounts can logout of using Notify API
- [Push Notification best practices](#push-notification-best-practices): 
  Guidelines on how to implement Push Notifications across different platforms


**Extra (Platform Specific)**: Additional information for platform specific usage. Some useful topics covered in this 
section are:


- [Firebase Cloud Messaging setup **(Android)**](?platform=android#firebase-cloud-messaging-setup):
  Configuring `FirebaseMessagingService` wrapper in order to decrypt notifications
- [NotifyClient.Delegate **(Android)**](?platform=android#notifyclientdelegate): 
  Setting and overriding functions through NotifyDelegate.
- @Artur are there any iOS platform specific sections to be added?

To check the full list of platform specific instructions for your preferred platform, go to [Extra (Platform Specific)](#extra-platform-specific) and select your platform.

## Initialization

<CloudBanner />

<PlatformTabs
	groupId="w3w"
	activeOptions={["ios","android", "react-native"]}
>
<PlatformTabItem value="ios">

Configure the `Notify` instance with:

```swift
try Notify.configure(groupIdentifier: String, environment: APNSEnvironment, crypto: CryptoProvider)
```

`groupIdentifier` - App group identifier, created on Apple Developer portal. Enables to share keychain items between the Notify SDK and a UNNotificationServiceExtension to receive and decrypt push notifications.

`environment` - Use `debug` environment for debug builds and `release` for release and TestFlight builds.

`crypto` - CryptoProvider is a protocol, you are required to provide an implementation of `recoverPubKey` and `keccak256` methods.


#### Sign a SIWE message to view and manage notifications

To login to manage notifications, you must call the `register()` method and supply an `onSign` callback. The Notify SDK will call this callback with the SIWE message to sign, and the signature to be returned. Once logged in, cross-device syncing will be enabled.

```swift
Notify.instance.register(account: account, domain: domain, onSign: onSign)
```

- `account` - An CAIP-10 account that the identity key will be issued for
- `domain` - A domain of your wallet, you should use your bundle ID
- `onSign` - callback that requests a signature from the user  

Provide your own sign function implementation that returns CacaoSignature. See our sample wallet app for a [more detailed example](https://github.com/WalletConnect/WalletConnectSwiftV2/blob/5ab573d9d3cd1cd641bf6d422c33e29b30226d36/Example/Shared/ImportAccount.swift#L94).

```swift
func onSign(message: String) -> SigningResult {
    let signature = try! signer.sign(message: message)
    return .signed(signature)
}
```

</PlatformTabItem>
<PlatformTabItem value="android">

To initialize the Notify client, create a `Notify.Params.Init` object in the Android Application class with the Core Client passed as a parameter. The `Notify.Params.Init` object will then be passed to the `Notify.initialize` function. There is also an `onError` callback that will need to be provided which will return an instance of `Notify.Model.Error` if there's an issue initializing the client.

**Note:** The CoreClient used here will be the same instance of the CoreClient used in other WalletConnect Kotlin SDKs

```kotlin
val projectId = PROJECT_ID
val serverUrl = "wss://relay.walletconnect.com?projectId=$projectId"
val appMetaData = Core.Model.AppMetaData(
    name = /* The name of your project as a String */,
    description = /* A description of your project as a String */,
    url = /* A url for your project as a String */,
    icons = /* A list of URLs to icons related to your project as Strings */,
    redirect = /* A redirect URI used by Dapps to deeplink back to your wallet. This is a String value  */
)

CoreClient.initialize(relayServerUrl = serverUrl, connectionType = ConnectionType.AUTOMATIC, application = this, metaData = appMetaData)

Notify.initialize(init = Notify.Params.Init(core = CoreClient) { error: Notify.Model.Error ->
    // Error will be thrown if there's an issue during initialization
}
```

</PlatformTabItem>
<PlatformTabItem value="react-native">


#### Initialize the SDK clients

```javascript
import { NotifyClient } from '@walletconnect/notify-client'

const notifyClient = await NotifyClient.init({
  projectId: '<YOUR PROJECT ID>'
})
```

</PlatformTabItem>
</PlatformTabs>

## Account login

:::caution
Update me after new specs change of the new registration flow
:::

The NotifyClient, once [initialized](#initialization), requires the registration of a [CAIP-10 account](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) to receive notifications for given blockchain account

**`NotifyClient.register`**: This method is utilized to authenticate ownership of a blockchain account during the registration of Identity Keys with [WalletConnect's Keys Server](../../specs/servers/keys/readme.md). It requires end users to sign a message using the **`onSign(message: String)`** callback. Presently, the Keys Server supports only EIP191 signatures. The use of Identity Keys aims to enhance the User Experience by reducing the frequency of signature requests while maintaining authenticated actions. 

Message in **`onSign(message: String)`** is a SIWE message that varies depending if the app is requesting access to manage all app notifications, or just that app's own notifications. Read more [here](../../web3inbox/authorization-signatures/about.mdx)

**Best Practices**

It’s advised to call this method at least once per app start up, it will ensure that account is registered with the latest valid SIWE statement required by Notify API

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>

## Subscribing to a new dapp

To begin receiving notifications from a dapp, users must opt-in by subscribing. This subscription process grants permission for the dapp to send notifications to the user. These notifications can serve a variety of purposes, such as providing updates on the user's blockchain account activities or informing them about ongoing campaigns within the dapp. Upon initial subscription, clients will be automatically enrolled to receive all types of notifications as defined by the dapp at that moment. Users have the flexibility to modify their notification settings later, allowing them to tailor the types of alerts they receive according to their preferences. 

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>

## Fetching active subscriptions

To fetch the current list of subscriptions an account has, call **`NotifyClient.getActiveSubscriptions()`**. 

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Fetching subscription’s notifications

To fetch subscription’s notifications by calling **`NotifyClient.getMessageHistory()`**.

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Updating subscriptions notification settings

Users can alter their notification settings to filter out unwanted alerts from a dapp. During this process, they review and select the types of notifications they wish to receive, based on the latest options provided by the dapp. Available notification types fetching is shown in the [next section](#fetching-available-notification-types).

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Fetching available notification types

Developers can fetch latest notification types specified by dapp by calling **`NotifyClient.getNotificationTypes()`** function. 

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Unsubscribe from a dapp

To opt-out of receiving notifications from a dap, a user can decide to unsubscribe from dapp.

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Delete subscription message

Once a notification is viewed, you may want to remove the message from the client’s storage to keep the UI/UX clean for users.

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>


## Account logout

If an account is removed from the client or a user no longer wants to receive notifications for this account, you can logout the account from Notify API by calling **`NotifyClient.unregister()`**. This will remove all subscriptions and messages for this account from the client’s storage.

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>

## Push Notification best practices

To create a good user experience and to guide users into unsubscribing from the correct dapp, there are certain best practices when displaying push notifications.

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

</PlatformTabItem>
<PlatformTabItem value="android">

`Notify.Model.Message` contains a `type` field, which is a unique id of the notification type. It is recommended to use this field as a notification channel id. By doing so it will create a channel for each notification type. To allow users to granularly control which notifications they want to receive within system settings, it is recommended to create a separate channel for every dapp and every notification type they might have. By doing so user would be able to turn off notifications for specific notification type per every subscribed dapp.

```kotlin
override fun onMessage(message: Notify.Model.Message, originalMessage: RemoteMessage) {
    val appMetadata = NotifyClient.getActiveSubscriptions()[message.topic]?.metadata ?: throw IllegalStateException("No active subscription for topic: ${message.topic}")
    val appDomain = URI(appMetadata.url).host ?: throw IllegalStateException("Unable to parse domain from $appMetadata.url")

    val typeName = NotifyClient.getNotificationTypes(Notify.Params.NotificationTypes(appDomain))[message.type]?.name
        ?: throw IllegalStateException("No notification type for topic:${message.topic} and type: ${message.type}")
    
    val channelId = message.type
    val channelName = (appMetadata.name + ": " + typeName)

    val notificationBuilder = NotificationCompat.Builder(this, channelId)
        .setContentTitle(message.title)
        .setSmallIcon(android.R.drawable.ic_popup_reminder) // specify icon for notification
        .setContentText(message.body)
        .setAutoCancel(true) // clear notification after click
        .setSound(defaultSoundUri) // specify sound for notification
        .setContentIntent(pendingIntent) // specify pendingIntent

    // Since android Oreo notification channel is needed.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)
        notificationManager.createNotificationChannel(channel)
    }

    notificationManager.notify(message.hashCode(), notificationBuilder.build()) // specify id of notification
}
```
</PlatformTabItem>
<PlatformTabItem value="react-native">

</PlatformTabItem>
</PlatformTabs>

## Extra (Platform Specific)

<PlatformTabs activeOptions={["ios","android", "react-native"]}>
<PlatformTabItem value="ios">

#### Configure your project to enable Push Notifications

[Configure Project](../../advanced/echo-server.md)

#### Register for Push Notifications

In order to enable Push Notifications for your app you need to follow standard procedure:

[Enable Push Notifications Capability](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns#2980170)

Ask for user permissions:

call registerForPushNotifications() early in your app's lifecycle to initiate the registration process with Apple Push Notification service:

```swift
    func registerForPushNotifications() {
        UNUserNotificationCenter.current()
            .requestAuthorization(
                options: [.alert, .sound, .badge]
            ) { granted, error in
                guard granted else { return }
                DispatchQueue.main.async {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
    }
```

Receive token from Apple Push Notification Services and register it at the Push Server:

```swift
    func application(
      _ application: UIApplication,
      didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
    ) {
        Task(priority: .high) {
            try await Notify.instance.register(deviceToken: deviceToken)
        }
    }
```

#### Decrypting Push Notifications

Push notifications sent via APNs are encrypted and carry the following payload:

```
{
  "aps": {
    "content-available": 1,
    "mutable-content": 1
  },
  "ciphertext": "encrypted-payload",
  "topic": "subscription_topic",
}
```

To decrypt a Push Notification (PN), you need to instantiate a [UNNotificationServiceExtension](https://developer.apple.com/documentation/usernotifications/unnotificationserviceextension).

For details on how to modify the content in newly delivered notifications, refer to the official Apple Developer Documentation [here](https://developer.apple.com/documentation/usernotifications/modifying_content_in_newly_delivered_notifications).

Additionally, you will need to create a [keychain group](https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps) that is shared between your wallet application and the notification service. 

Inside your notification service extension file, import WalletConnectNotify, initialize `NotifyDecryptionService()`, and decrypt the message with the following Swift code:

```swift
override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -> Void) {
    bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
    if let bestAttemptContent = bestAttemptContent {
        let topic = bestAttemptContent.userInfo["topic"] as! String
        let ciphertext = bestAttemptContent.userInfo["blob"] as! String
        do {
            let service = NotifyDecryptionService(groupIdentifier: "your_app_group_identifier")
            let pushMessage = try service.decryptMessage(topic: topic, ciphertext: ciphertext)
            bestAttemptContent.title = pushMessage.title
            bestAttemptContent.body = pushMessage.body
            contentHandler(bestAttemptContent)
            return
        }
    ...
}
```

</PlatformTabItem>
<PlatformTabItem value="android">

### Firebase Cloud Messaging setup

To enable push notifications, first you'll need to [configure your project](/docs/advanced/echo-server.md) with Firebase Messaging service.

### NotifyClient.Delegate

:::caution
Needs update. This should link to push notification tab from web3wallet. Using old content for now
:::caution

The `NotifyMessageService` is a wrapper around the `FirebaseMessagingService`. The `NotifyMessageService` class needs to be implemented for the Notify SDK to be able to decrypt and notify wallets of a push notification sent from the Dapp in the background.
This service also needs to be registered in the AndroidManifest.xml file similar to the example in the [FCM documentation](https://firebase.google.com/docs/cloud-messaging/android/client#manifest).

```kotlin
class SampleFirebaseService: NotifyMessageService() {

    override fun newToken(token: String) {
        // Triggered when Firebase Cloud Messaging creates a new token and that token is registered with the Push server
    }

    override fun registeringFailed(token: String, throwable: Throwable) {
        // Triggered when Firebase Cloud Messaging if there is an error with registering with the Push server with a new token
    }

    override fun onMessage(message: Notify.Model.Message, originalMessage: RemoteMessage) {
        // Triggered when a message is sent from the Push server through Firebase Cloud Messaging and the message contains `Notify.Model.Message`. The original FCM RemoteMessage is also returned
    }

    override fun onDefaultBehavior(message: RemoteMessage) {
        // Triggered when a message is sent from the Push server through Firebase Cloud Messaging and the message does not contain `Notify.Model.Message` in the payload. The original FCM RemoteMessage returned instead
    }

    override fun onError(throwable: Throwable, defaultMessage: RemoteMessage) {
        // Triggered when there is an error that occurs when a message is received from the Push server
    }
}
```

```xml
<application...>
    <service android:name=".SampleFirebaseService">
        <intent-filter>
            <action android:name="com.google.firebase.MESSAGING_EVENT" />
        </intent-filter>
    </service>
</application>
```

</PlatformTabItem>
<PlatformTabItem value="react-native">

Install [`@react-native-firebase/messaging`](https://www.npmjs.com/package/@react-native-firebase/messaging) and [`@notifee/react-native`](https://www.npmjs.com/package/@notifee/react-native) to handle Push Notifications.
Please refer to the respective package documentation to configure them properly.

```bash npm2yarn
npm install @notifee/react-native @react-native-firebase/messaging
```

Update your index.js file to include the following logic.

```js
import {AppRegistry, PermissionsAndroid} from 'react-native';
import App from './App';
import {name as appName} from './app.json';
import './expo-crypto-shim.js'
import messaging from '@react-native-firebase/messaging';
import notifee, {
  AndroidImportance,
  AndroidVisibility,
  EventType,
} from '@notifee/react-native';
import {NotifyClient} from '@walletconnect/notify-client';
import {Core} from '@walletconnect/core';

let notifyClient;

const projectId = process.env.ENV_PROJECT_ID;
const relayUrl = process.env.ENV_RELAY_URL;
const core = new Core({
  projectId,
  relayUrl,
});

async function registerClient(deviceToken, clientId) {
  const body = JSON.stringify({
    client_id: clientId,
    token: deviceToken,
    type: 'fcm',
  });

  const requestOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body,
  };

  return fetch(
    `https://echo.walletconnect.com/${projectId}/clients`,
    requestOptions,
  )
    .then(response => response.json())
    .then(result => console.log(result))
    .catch(error => console.log('error', error));
}

messaging()
  .getToken()
  .then(token => console.log({token}));

messaging().onTokenRefresh(async token => {
  const status = await messaging().requestPermission(
    PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
  );
  const enabled =
    status === messaging.AuthorizationStatus.AUTHORIZED ||
    status === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    notifyClient = await NotifyClient.init({
      core,
      projectId,
      relayUrl,
    });
    const clientId = await notifyClient.core.crypto.getClientId();
    return registerClient(token, clientId);
  }

  return;
});

notifee.createChannel({
  id: 'default',
  name: 'Default Channel',
  lights: false,
  vibration: true,
  importance: AndroidImportance.HIGH,
  visibility: AndroidVisibility.PUBLIC,
});

messaging().setBackgroundMessageHandler(async remoteMessage => {
  if (!notifyClient) {
    notifyClient = await NotifyClient.init({
      core,
      projectId,
      relayUrl,
    });
  }
  if (!remoteMessage.data?.blob || !remoteMessage.data?.topic) {
    console.log('Missing blob or topic on notification message.');
    return;
  }

  const decryptedMessage = await notifyClient?.decryptMessage({
    topic: remoteMessage.data?.topic,
    encryptedMessage: remoteMessage.data?.blob,
  });

  // Display a notification
  return notifee.displayNotification({
    title: decryptedMessage.title,
    body: decryptedMessage.body,
    android: {
      channelId: 'default',
      importance: AndroidImportance.HIGH,
      visibility: AndroidVisibility.PUBLIC,
      smallIcon: 'ic_launcher', // optional, defaults to 'ic_launcher'.
      // pressAction is needed if you want the notification to open the app when pressed
      pressAction: {
        id: 'default',
      },
    },
  });
});

notifee.onBackgroundEvent(async ({type, detail}) => {
  const {notification, pressAction} = detail;

  // Check if the user pressed the "Mark as read" action
  if (type === EventType.ACTION_PRESS && pressAction.id === 'mark-as-read') {
    // Remove the notification
    await notifee.cancelNotification(notification.id);
  }
});

function HeadlessCheck({isHeadless}) {
  if (isHeadless) {
    // App has been launched in the background by iOS, ignore
    return null;
  }

  // Render the app component on foreground launch
  return <App />;
}

AppRegistry.registerComponent(appName, () => HeadlessCheck);
```
</PlatformTabItem>
</PlatformTabs>


